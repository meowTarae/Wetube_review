<!-- 
1.  
    a(href="/edit")     
        => 내 위치와는 관계없이 root/edit 로 이동

    a(href="edit")     
        => 내 위치/edit 로 이동


2. 
    form() - method는 default값이 get이므로,
    db로 값을 보내는 등의 행위시에는 method="POST"를 해주자.
    특정 url로 보내려면 action을 수정해주면 됨.


3. res.redirect()
    브라우저가 자동으로 우리가 준 url 로 이동


4. 
    라우터 파일에서 
    cat.get("/churr", getChurr);
    cat.post("/churr", postChurr);

    (shortCut) => cat.router("/churr").get(getChurr).post(postChurr);


5. 
    HTML에서 
    input(name="title", placeholder="Video Title", value=video.title, required)
        // placeholder는 입력칸이 공백일때 나타나는 텍스트
        // value는 입력칸에 적혀있는 텍스트
    
    라는 입력칸이 있다고 가정.
    이때 해당 입력칸의 이름은 'title' 이다.
    title = `${video.title}`; 이다.


6. form으로부터 정보를 얻을 때
    express를 설정 해줘야함.
    
    server.js에 
    app.use(express.urlencoded({ extended: true })); 를 추가.
    
    => req.body (= html로부터의 input-value) 값을 url에 인코딩해서 가져올 수 있게 해줌.
 

7. mongo DB
    document-based (문서 기반)
    일반적인 db는 sql 베이스, 행 기반이다.

    mongo에서 저장하는 데이터는 JSON-like-document이다.
    따라서 행으로 된 데이터를 저장할 필요 X


8. mongoose
    node.js와 mongoDB를 이어주는 역할
    (우리가 작성한 js를 db로 보내줌)


9. mongoDB 사용 방법

    mongod: MongoDB 시스템의 기본 데몬 프로세서 (서버와 같은 느낌) 
    // mongo demon
    mongo: MongoDB에 대한 쉘 인터페이스 (클라이언트 같은 느낌)

    즉 mongod로 서버를 키고 -> mongo로 인터페이스를 실행하여 mongoDB와 소통한다 -->


10. CRUD
    Create, Read, Update, Delete


11. 
    db에게 데이터 형식을 알려줘야 함.
    타입스크립트처럼, tarae에는 meow가 있고 이건 string이야..
        => schema
            const videoSchema = new mongoose.Schema({
                title: String,
                    // 혹은 title: { type: String },
                date: Date,
                hashtags: [{ type: String }],
            });

                // hashtags 실 데이터
                hastags: [
                    "#hi",
                    "#mongo",
                ]
                == hashtags: hashtags.split(",").map((w) => w);


    이를 통해 db는 모델을 구축할 수 있음.
        const movieModel = mongoose.model("Video", videoSchema);
                                        // 모델명, schema 


12. 
    mongoose query는 2가지 중 하나로 사용될 수 있음
        1. callback
            무언가가 발생하고 난 후 호출되는 함수
                ex) 마우스 클릭 이벤트가 발생한다던가..
            
        2. promise
            callback의 최신 버전 느낌?
            async / await 이다.
            
            기존 JS는 기다리는 기능이 없다. 

            코드를 위에서 아래로 읽다보면
            DB 건드리는 어떤 코드의 경우, 시간이 오래걸려
            해당 코드보다 아래줄의 코드가 먼저 실행되는 경우가 있다.
            이는 작업별로 시간이 달라 프로그램을 꼬이게 할 수 있음. 

            좀 오래걸리는 코드를 기다린 후, 다음 코드를 진행하는게 좋다고 판단.
            await를 DB 코드에 걸어두면 에러 없이 프로그램이 잘 실행될 수 있다.


            사용법 )
                1. 기존 callback 방식 )
                    const home = (req, res) => {
                        log("start");
                        Video.find({}, (err, video)) => {
                        ; Video는 schema,   video는 docs,
                            if (err) 
                                log("errr~~");
                            return res.render("/tarea", { tarae });
                            log("doing");
                        }
                        log("finisg");
                    }
                    위 코드는 start, doing, finish 순서가 아닌,
                             start, finish, doing 순서로 실행될 수 있다.


                2. async / await 사용시 )
                    const home = async (req, res) => {
                        log("start");
                        const videos = await Video.find({});
                        return res.render("/tarea", { tarae });
                        log("finisg");
                    }

                    위 코드는 순서대로 잘 진행됨 ㅇㅇ.
                    유의사항은, 시간이 좀 걸릴거같은 놈에게 await 걸어주기.
                    최고 외각 함수에게 (= home) async 걸어주기.

                    만약 err를 사용해야한다면 try / catch 문을 사용하자.
                        


13. 
    schmea를 만들고, pug 페이지에서 유저가 form-input에 값을 입력한다면
    우리는 해당 데이터를 controller에서 post func에서 관리할 수 있지 ㅇㅇ
    req.body로 부터 말이야.

    그리고 model을 정의하지.
    const video = new Video({
                    // schema 정의한 파일에서 수입한 변수임.
        title,
        ...
    })

    이제는 이렇게 '완성된' 모델을 DB에 전송할 차례임 !
    이를 위해
    
    video.save();
    이를 통해 documents가 db에 저장됨! 와우!
    
    save는 promise를 리턴받음. 
        >> save가 끝날때까지 기다려줘야함 == await를 꼭 붙여주세요


    위는 model을 따로 만들어놨을때 save()로 db에 보내는 방법이고
    아싸리 create()로 모델 자체를 선언과 동시에 db로 보낼 수 있음.
    create()를 사용하면 save() 안해도 된다 ㅇㅇ


14. documentation

    [0-9a-f]{24}
        >> 16진수의 24글자 를 뜻함.

    // regexpal.com에 들어가면 위의 regular expression 공부를 할 수 있덩


15. model.funcs()

    model.exists({ _id: id });
        >> _id는 mongo db에서 db.modelName.find() 했을때 id 명칭을 "_id"라 해놨더라구

    model.findById(id);
        >> id는 req.body.id 임 ㅇㅇ

    model.findByIdAndUpdate(id, { 
        수정할 것, 
        title, 
        hashtags: hashtags.split(",").map((w) => (w.startsWith("#") ? w : `#${word}`)),
    })

    etc...


16. 